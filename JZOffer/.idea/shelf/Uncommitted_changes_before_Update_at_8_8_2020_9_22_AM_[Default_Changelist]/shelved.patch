Index: JZCode/src/cn/matthew/jzoffer/JZ08.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package cn.matthew.jzoffer;\r\n\r\n/**\r\n * @description:\r\n * @date: 8/6/2020\r\n * @author: 大帅\r\n * @version:\r\n */\r\npublic class JZ08 {\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- JZCode/src/cn/matthew/jzoffer/JZ08.java	(revision de7cb1c0728121244b4752613afd6ed85b671cf2)
+++ JZCode/src/cn/matthew/jzoffer/JZ08.java	(date 1596784948486)
@@ -1,10 +1,16 @@
 package cn.matthew.jzoffer;
 
 /**
- * @description:
+ * @description: 二叉树的下一个节点
  * @date: 8/6/2020
  * @author: 大帅
  * @version:
  */
+
+/*
+题目：
+给定一棵二叉树和其中一个节点，如何找出中序遍历序列的下一个节点？
+树中的节点除了有两个分别指向左右节点的指针，还有一个指向父节点的指针。
+ */
 public class JZ08 {
 }
Index: JZCode/src/cn/matthew/jzoffer/JZ1001.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- JZCode/src/cn/matthew/jzoffer/JZ1001.java	(date 1596794669793)
+++ JZCode/src/cn/matthew/jzoffer/JZ1001.java	(date 1596794669793)
@@ -0,0 +1,18 @@
+package cn.matthew.jzoffer;
+
+/**
+ * @description: 斐波那契数列
+ * @date: 8/7/2020
+ * @author: 大帅
+ * @version:
+ */
+
+/*
+求斐波那契数列的第n项
+写一个函数，输入n，求斐波那契数列的第n项,斐波那契数列的定义如下
+f(n) = 0,n=0
+f(n) = 1,n=1
+f(n) = f(n-1)+f(n-2),n>1
+ */
+public class JZ1001 {
+}
Index: JZCode/src/cn/matthew/jzoffer/JZ09.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- JZCode/src/cn/matthew/jzoffer/JZ09.java	(date 1596793910012)
+++ JZCode/src/cn/matthew/jzoffer/JZ09.java	(date 1596793910012)
@@ -0,0 +1,16 @@
+package cn.matthew.jzoffer;
+
+/**
+ * @description: 用两个栈实现队列
+ * @date: 8/7/2020
+ * @author: 大帅
+ * @version:
+ */
+
+/*
+题目：
+用两个栈实现一个队列。队列的声明如下，请实现它的两个函数appendTail和deleteHead，
+分别完成在队尾插入节点和在队列头部删除节点的功能
+ */
+public class JZ09 {
+}
Index: JZCode/src/cn/matthew/jzoffer/JZ12.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- JZCode/src/cn/matthew/jzoffer/JZ12.java	(date 1596795275994)
+++ JZCode/src/cn/matthew/jzoffer/JZ12.java	(date 1596795275994)
@@ -0,0 +1,17 @@
+package cn.matthew.jzoffer;
+
+/**
+ * @description: 矩阵中的路径
+ * @date: 8/7/2020
+ * @author: 大帅
+ * @version:
+ */
+
+/*
+题目：
+请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。
+路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。
+如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。
+ */
+public class JZ12 {
+}
Index: JZCode/src/cn/matthew/jzoffer/JZ11.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- JZCode/src/cn/matthew/jzoffer/JZ11.java	(date 1596794839375)
+++ JZCode/src/cn/matthew/jzoffer/JZ11.java	(date 1596794839375)
@@ -0,0 +1,17 @@
+package cn.matthew.jzoffer;
+
+/**
+ * @description: 旋转数组中的最小数字
+ * @date: 8/7/2020
+ * @author: 大帅
+ * @version:
+ */
+
+/*
+题目：
+把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
+输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。
+例如，数组｛3，4，5，1，2｝是数组｛1，2，3，4，5｝的一个旋转，该数组的最小值为1
+ */
+public class JZ11 {
+}
Index: JZCode/src/cn/matthew/jzoffer/JZ1002.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- JZCode/src/cn/matthew/jzoffer/JZ1002.java	(date 1596794669758)
+++ JZCode/src/cn/matthew/jzoffer/JZ1002.java	(date 1596794669758)
@@ -0,0 +1,14 @@
+package cn.matthew.jzoffer;
+
+/**
+ * @description: 青蛙跳台阶问题
+ * @date: 8/7/2020
+ * @author: 大帅
+ * @version:
+ */
+
+/*
+一只青蛙一次可以跳上1级台阶，也可以跳上两级台阶。求该青蛙一个n级台阶一共有多少种跳法。
+ */
+public class JZ1002 {
+}
Index: JZCode/src/cn/matthew/jzoffer/JZ0702.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package cn.matthew.jzoffer;\r\n\r\n\r\nimport java.util.Stack;\r\n\r\n/**\r\n * @description: 二叉树的 6 种遍历\r\n * @date: 8/7/2020\r\n * @author: 大帅\r\n * @version:\r\n */\r\n\r\n/*\r\n二叉树有前序遍历、中序遍历和后序遍历。每一种遍历里面又可以分为递归实现和循环实现。\r\n前序遍历：先访问根节点，再访问左子节点，最后访问右子节点，10-6-4-8-14-12-16\r\n中序遍历：先访问左子节点，再访问根节点，最后访问右子节点，4-6-8-10-12-14-16\r\n后序遍历：先访问左子节点，再访问右子节点，最后访问根节点，4-8-6-12-16-14-10\r\n以下为一种示例的树结构\r\n      10\r\n   /     \\\r\n  6      14\r\n / \\    /  \\\r\n4   8  12  16\r\n\r\n */\r\npublic class JZ0702 {\r\n    public static void main(String[] args) {\r\n        TreeNode root = JZ0702.init();\r\n        System.out.println(\"前序遍历\");\r\n        preOrder(root);\r\n        System.out.println(\"中序遍历\");\r\n        inOrder(root);\r\n        System.out.println(\"后序遍历\");\r\n        postOrder(root);\r\n        System.out.println(\"非递归前序遍历\");\r\n        normalPreOrder(root);\r\n        System.out.println(\"非递归中序遍历\");\r\n        normalInOrder(root);\r\n        System.out.println(\"非递归后序遍历\");\r\n        normalPostOrder(root);\r\n    }\r\n\r\n    /**\r\n     * 打印传入的节点\r\n     * @param treeNode 输入的结点\r\n     */\r\n    private static void printNode(TreeNode treeNode){\r\n        System.out.println(treeNode.getVal());\r\n    }\r\n\r\n    /**\r\n     * 递归实现前序遍历：根 - 左 - 右\r\n     * @param root 根节点\r\n     */\r\n    private static void preOrder(TreeNode root) {\r\n        printNode(root);\r\n        if (root.getLeft() != null) preOrder(root.getLeft());\r\n        if (root.getRight() != null) preOrder(root.getRight());\r\n    }\r\n\r\n    /**\r\n     * 递归实现中序遍历：左 - 根 - 右\r\n     * @param root 根节点\r\n     */\r\n    private static void inOrder(TreeNode root){\r\n        if (root.getLeft() != null) inOrder(root.getLeft());\r\n        printNode(root);\r\n        if (root.getRight() != null) inOrder(root.getRight());\r\n    }\r\n\r\n    /**\r\n     * 递归实现后序遍历：左 - 右 - 根\r\n     * @param root 根节点\r\n     */\r\n    private static void postOrder(TreeNode root){\r\n        if (root.getLeft() != null) postOrder(root.getLeft());\r\n        if (root.getRight() != null) postOrder(root.getRight());\r\n        printNode(root);\r\n    }\r\n\r\n    /**\r\n     * 非递归实现前序遍历：根 - 左 - 右\r\n     * @param root\r\n     */\r\n    private static void normalPreOrder(TreeNode root){\r\n        Stack<TreeNode> stack = new Stack<>();\r\n        TreeNode node = root;\r\n        while (node != null || stack.size() > 0){\r\n            if (node != null){\r\n                printNode(node);\r\n                stack.push(node);\r\n                node = node.getLeft();\r\n            }else {\r\n                node = stack.pop();\r\n                node = node.getRight();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 非递归实现中序排列：左 - 根 - 右\r\n     * @param root\r\n     */\r\n    private static void normalInOrder(TreeNode root){\r\n        Stack<TreeNode> stack = new Stack<>();\r\n        TreeNode node = root;\r\n        while (node != null || stack.size() > 0){\r\n            if (node != null){\r\n                stack.push(node);\r\n                node = node.getLeft();\r\n            }else {\r\n                node =stack.pop();\r\n                printNode(node);\r\n                node = node.getRight();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 非递归实现后序遍历：左 - 右 - 根\r\n     * @param root\r\n     */\r\n    private static void normalPostOrder(TreeNode root){\r\n        Stack<TreeNode> stack = new Stack<>();\r\n        Stack<TreeNode> out = new Stack<>();\r\n        TreeNode node = root;\r\n        while (node != null || stack.size() > 0 ){\r\n            if (node != null){\r\n                stack.push(node);\r\n                out.push(node);\r\n                node = node.getRight();\r\n            }else {\r\n                node = stack.pop();\r\n                node = node.getLeft();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 初始化树结构\r\n     * @return 返回 root节点\r\n     */\r\n    private static TreeNode init() {\r\n        TreeNode A = new TreeNode(10);\r\n        TreeNode B = new TreeNode(6);\r\n        TreeNode C = new TreeNode(4);\r\n        TreeNode D = new TreeNode(8);\r\n        TreeNode E = new TreeNode(14);\r\n        TreeNode F = new TreeNode(12);\r\n        TreeNode G = new TreeNode(16);\r\n        A.left = B;\r\n        B.left = C;\r\n        B.right = D;\r\n        A.right = E;\r\n        E.left = F;\r\n        E.right = G;\r\n        return A;\r\n    }\r\n}\r\n\r\n/**\r\n * TreeNode类，定义了树的结构\r\n */\r\nclass TreeNode{\r\n    int val;\r\n    TreeNode left = null;\r\n    TreeNode right = null;\r\n\r\n    public TreeNode(int val) {\r\n        this.val = val;\r\n    }\r\n\r\n    public int getVal() {\r\n        return val;\r\n    }\r\n\r\n    public void setVal(int val) {\r\n        this.val = val;\r\n    }\r\n\r\n    public TreeNode getLeft() {\r\n        return left;\r\n    }\r\n\r\n    public void setLeft(TreeNode left) {\r\n        this.left = left;\r\n    }\r\n\r\n    public TreeNode getRight() {\r\n        return right;\r\n    }\r\n\r\n    public void setRight(TreeNode right) {\r\n        this.right = right;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- JZCode/src/cn/matthew/jzoffer/JZ0702.java	(revision de7cb1c0728121244b4752613afd6ed85b671cf2)
+++ JZCode/src/cn/matthew/jzoffer/JZ0702.java	(date 1596791185706)
@@ -1,6 +1,5 @@
 package cn.matthew.jzoffer;
 
-
 import java.util.Stack;
 
 /**
