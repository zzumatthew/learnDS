# 数据结构与算法文字概述

## 数据结构

- 链表
  - 链表的特点是：增删快，但是查找慢。增加数据的时候只需要改变前后数据的指针的指向就行，删除数据的时候只需要将需要删除的数据的前后指针都移除，甚至都不需要将数据真正的删除。因为所有的数据都是用链条连接的，所以查询起来会很麻烦，需要一个一个的找。
- 数组
  - 数组的特点是：查找快，但是增删慢。因为数组具有随机访问的特点，需要访问的数据可以通过数组的下标计算得到，所以可以直接根据下标来访问数组中的数据。增删慢是因为在调制数组中的数据之后需要调整数组的结构，不然数组中会出现空缺，导致数据不是存储在连续的空间中。
- 栈
  - 栈中的数据也是线性排列的，在栈中，数据的操作只能是一端进行，访问数据也只能是访问都顶端的数据，想要访问中间的数据时，就必须通过栈操作，将目标数据移动到栈顶才行。
- 队列
  - 队列中的数据是可以在两端进行操作的，但是队列依旧不能访问中间的数据，必须通过出队列的操作将目标数据变成首位之后才可以访问。
- 哈希表
  - 在哈希表中，可以通过哈希函数快速的获取到数组中的目标数据，如果发生哈希冲突，那么就使用链表进行存储，这样一来，不管数据量为多少，都可以灵活进行应对。
  - 但是当数组的空间太小，那么就很容易发生哈希冲突，线性查找的使用频率会比较高；反过来，如果数组的空间太大，就有可能出现很多空箱子，造成内存的浪费。（所以就需要合理的选择数组的空间）

* 堆
  
  - 堆中的每个结点最多有两个子结点。在堆中必须遵守：子结点必须大于父结点。在新添加数据的时候，一般会把新数据放在最下面一行靠左的位置。当下面的一行里面没有多余的空间时，就再往下另起一行，把数据加在这一行的最左边。
  
* 二叉查找树

  * 二叉查找树最好的情况之下，复杂度为O（logn），最坏的情况下其复杂度为O（n）

  * AVL树

    * AVL树要求任意一个结点的左子树和右子树的深度之差不超过1，以此来保证复杂度

  * 红黑树

    * 红黑树是对二叉查找树的改进，是一种平衡的二叉查找树，不管在什么情况下都是O（logn）。红黑树的要求跟AVL树的要求不一样。

    * 四个性质

      1. 每个结点要么是红色的，要么是黑色的
      2. 根节点是黑色的
      3. 如果一个结点是红色的，则它的两个孩子都是黑色的
      4. 对于任意一个结点，它到叶子结点的每条路径上都包含有相同数量的黑色结点

    * 插入操作

      1. 每次加入一个新的结点，那么就将这个结点涂成红色

      2. 新加入的结点可能会遇到以下某种情况

         1. 新加入的结点是根节点，那么就需要把新加入的结点涂成黑色

         2. 新加入的结点的父结点是黑色，那就什么也不需要做，整个树依旧是一个红黑树

         3. 新加入的结点的父结点是红色，那么就是违背性质3，此时需要做调整（一是变色，二是旋转，左旋就是逆时针操作，右旋就是顺时针操作）

            1. 当前结点的父亲是红色，叔叔存在且也是红色

               那么就把父结点和叔叔结点涂成黑色，祖父结点涂成红色

            <img src="https://resource.ethsonliu.com/image/20191118_04.png" alt="img" style="zoom:80%;" />

            2. 当前结点的父亲是红色，叔叔结点不存在或者是黑色，而且当前结点是父亲结点的右孩子

               - 将父亲结点设置为当前节点
               - 以新的当前结点进行左旋
               - 依然不满足红黑树的条件转到3

               ![img](https://resource.ethsonliu.com/image/20191118_05.png)

            3. 当前结点的父亲是红色，叔叔不存在或者是黑色，而且当前结点是父亲结点的左孩子

               - 将父亲结点改为黑色
               - 将祖父结点改为红色
               - 以父亲节点为支点进行右旋

               ![img](https://resource.ethsonliu.com/image/20191118_06.png)

               

    * 删除操作
      1. 被删除的结点没有孩子，如果它是红色的，那么可以直接删除
      2. 被删除的结点只有一个孩子，那么删除之后用孩子结点代替这个被删除的结点
      3. 被删除的结点有两个孩子，那么先找出它的后继结点，然后用后继结点去替换被删除的结点，把问题转化为删除后继结点，也就是说，后继结点才是真正被删除的结点

## 排序

- 冒泡排序
  - 冒泡序列就是重复“从序列右边开始比较相邻数字的大小，再根据结果交换两个数字的位置”。
  - 每一轮比较，序列的最右边相当于有一个天平，每次天平会向序列的最左边移动一下，每次比较会把较小的（或者是较大的，看需求）数字移动到序列的左边，那么一共经过几轮之后就会实现所有的数字按照从小到大（或者是从大到小）的顺序排列。冒泡排序的复杂度为O（n^2），复杂度比较高，不适合数据量比较大的序列。
- 选择排序
  - 选择排序就是重复“从待排序列的数据中寻找最小值，将其余序列最左边的数字进行比较，根据比较的结果交换数字的位置”。在序列中寻找最小值使用的是线性查找。
  - 选择排序中，最左的数字是已经排好了顺序的，右边的数字是没有排好顺序的，所以每一轮都是在右边的数字中用线性查找的方法找到最小值，与这一轮的左边的数字进行大小比较确定顺序。选择排序的复杂度为O（n^2），复杂度比较高，不适合数据量比较大的序列。
- 插入排序
  - 插入排序中，序列的左边是已经排好序的，序列的右边是没有排序的。每一次都是从序列的右边取出数字，将其安插在序列左边合适的位置上，这就是插入排序。
  - 插入排序的复杂度是O（n^2），所以依旧只适用于数据量不大的序列。
- 堆排序
  - 
- 归并排序
- 快速排序
  - 快速排序中，每次随机选择一个基准值，将序列中的数字分为比基准值小的和比基准值大的两部分，两部分中继续用上面的法，直到序列中只有一个数，表示排序完成。快速排序有一种分而治之的思想。同时也用到了递归的思想。最坏的情况（每次选的基准值都是最小值）下的复杂度为O（n^2），普通情况下为O（nlogn）。

## 查找

- 线性查找
  - 在数组中从头开始按顺序检查数据，直到找到需要查询的数据。复杂度为O（n）。
- 二分查找
  - 二分查找只能处理已经排好序的序列，